= Porting libjail to Erlang with NIFs method
:author:    Mathieu Kerjouan <contact@steepath.eu>
:twitter:   https://twitter.com/niamtokik
:backend:   slidy
:max-width: 50em
:icons:
:iconsdir: /usr/local/etc/asciidoc/images/icons
:images:
:imagesdir: ./img/
:copyright: Steepath <contact@steepath.eu>
:copyright: Mathieu Kerjouan <contact@steepath.eu>

== Introduction

Jails are a beautiful way to isolate applications on FreeBSD. Like all
containers technology, jails can group and isolate some process
running on an host.

On Linux, you have docker, written in Go. This project use all linux
kernel functionality to isolate and manage containers based on
namespace and cgroups technogies.

So, my project is pretty simple. I love Erlang, and I love FreeBSD,
can we connect libjail (one frontend to low-level jail management) to
Erlang beam throught NIFs (or/and ports)?

I want to start/stop/restart jails and get/set parameters with Erlang
functions.

== How to start?

Before starting any projects, we need documentation. We are lucky!
These two projects have lot of serious documentation about
everything.

=== FreeBSD Documentation and Source Code

What libraries we have in man pages?

 * https://www.freebsd.org/cgi/man.cgi?query=jail&sektion=3
 * https://www.freebsd.org/cgi/man.cgi?query=jail&sektion=2

Is some documentation exist on freebsd wiki?

 * https://wiki.freebsd.org/Jails

Where is stored userland source code?

 * https://svnweb.freebsd.org/base/releng/11.0/lib/libjail/
 * https://svnweb.freebsd.org/base/releng/11.0/usr.sbin/jail/
 * https://svnweb.freebsd.org/base/releng/11.0/usr.sbin/jls/

Where is stored kernelland source code?

 * https://svnweb.freebsd.org/base/releng/11.0/sys/kern/kern_jail.c
 * https://svnweb.freebsd.org/base/releng/11.0/sys/sys/jail.h

How works jails?

 * https://wiki.freebsd.org/VladimirKrstulja/Guides/Jails
 * https://www.freebsd.org/doc/handbook/jails.html
 * https://www.freebsd.org/doc/handbook/jails-build.html

Some papers or slides?

 * http://phk.freebsd.dk/pubs/sane2000-jail.pdf
 * http://phk.freebsd.dk/pubs/jails.pdf
 * https://www.usenix.org/legacy/event/usenix03/tech/freenix03/full_papers/zec/zec.pdf
 * https://www.defcon.org/images/defcon-14/dc-14-presentations/DC-14-ike.pdf

=== Erlang Documentation and Source Code

Erlang has multiple methods to talk to outside world. The more secure
approach is to use ports methods. The less secure but more performant
one (and much more risky) is NIFs.

Documentation about the BEAM?

 * https://github.com/happi/theBeamBook

Documentation about NIFs?

 * http://erlang.org/doc/tutorial/nif.html
 * http://erlang.org/doc/man/erl_nif.html
 
Some great videos?
 
 * https://www.youtube.com/watch?v=RMKSYWz_nPo
 * https://www.youtube.com/watch?v=41hNS39Xi8s
 * https://www.youtube.com/watch?v=_Pwlvy3zz9M
 * https://www.youtube.com/watch?v=qm0mbQbc9Kc
 * https://www.youtube.com/watch?v=_HQfS8efVeg

Is there exist other project who use NIFs or ports?

 * https://github.com/erlang/otp/tree/maint/lib/crypto/c_src
 * https://github.com/erlang/otp/tree/maint/lib/runtime_tools/c_src
 * https://github.com/erlang/otp/tree/maint/lib/asn1/c_src
 * https://github.com/erlang/otp/tree/maint/lib/wx/c_src
 
 * https://github.com/klacke/yaws/tree/master/c_src
 * https://github.com/Vagabond/erlang-syslog/tree/master/c_src
 
== What about C?

FreeBSD use clang/llvm. I'm not an expert in C, but, I just wrote code who works.
In C, we need a debugger, because your code will crash. We need also a way
to find if some memory leaks was done.

 * https://clang.llvm.org/docs/UsersManual.html#controlling-debug-information
 * https://lldb.llvm.org/

== Managing project

I use rebar3 for this project. erlang.mk work pretty well too, but I
want to use rebar3 for fun.

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
rebar3 new app name=erlang-jail
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

I use also fossil on my side and, when my code is working, convert it
to git.

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cd erlang-jail
fossil init erlang-jail.fossil
fossil open erlang-jail.fossil
# you can add now your file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

== Let's go!

Before interconnect Erlang with NIFs, I need to check how libjail
works. I will just test 2 simples functions: `int jail_getid(const
char*)` and `char *jail_getname(int)`. Let's write a simple C code:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <stdio.h>      // printf
#include <sys/param.h>  //
#include <sys/jail.h>   // needed for libjail (see man page)
#include <jail.h>       //

int
main(void) {
  printf("jail id: %d\n", jail_getid("myjail"));
  printf("jail name: %s\n", jail_getname(1));
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Compile your code:

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cc -ljail -o jailtset jailtest.c
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can now start a jail for testing this code:

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
jail -c name=myjail path=/ persist
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you have only this jail running, your program will output something
like that:

[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1
myjail
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

== Integrating this code in Erlang side

[makefile]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
INCLUDE = -I/usr/local/lib/erlang/usr/include
LIB = -ljail
CC_OPTS = -fpic -shared -Wall

jail_nif.so!
        cc $(LIB) $(INCLUDE) $(CC_OPTS) -o$@ jail.c jail_nif.c

clean:
        rm jail_nif.so
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <sys/param.h>
#include <sys/jail.h>
#include <jail.h>

extern char jail_errmsg[];

int
getid(char *name) {
  return jail_getid(name);
}

char *
getname(int jid) {
  char *ret = jail_getname(jid);
  if (ret)
    return ret;
  else
    return "";
}	      
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <erl_nif.h>
#define NAME_SIZE 1024

extern int getid(char *);
extern char * getname(int);

static ERL_NIF_TERM
getid_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]) {
    char *name = enif_alloc(NAME_SIZE);
    int ret;
    if (!enif_get_string(env, argv[0], name, NAME_SIZE, ERL_NIF_LATIN1))
      return enif_make_badarg(env);
    ret = getid(name);
    return enif_make_int(env, ret);
}

static ERL_NIF_TERM
getname_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]) {
    int id;
        char *ret;

    if (!enif_get_int(env, argv[0], &id))
            return enif_make_badarg(env);
    ret = getname(id);
    return enif_make_string(env, ret, ERL_NIF_LATIN1);
}

static ErlNifFunc
nif_funcs[] = {
    {"getid", 1, getid_nif},
    {"getname", 1, getname_nif}
};

ERL_NIF_INIT(jail, nif_funcs, NULL, NULL, NULL, NULL)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
make
erlc jail.erl
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[erlang]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
jail:getid("myjail").
% return 1

jail:getname(1).
% return myjail
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

== How works others functions?

Currently, documentation isn't pretty well written for others
functions. We'll use gdb to understand how other functions in libjail
works. Sometime, start debugger to see what a program do before
implementing it is a good idea.

My first idea was to create a test with some functions from
documentation and jls commands:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <sys/param.h>
#include <sys/jail.h>
#include <jail.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/errno.h>

int
main (void) {
  struct jailparam jp;

  if (jailparam_init(&jp, "jid")<0)
      printf("error 1\n");

  if (jailparam_import(&jp, "name")<0)
      printf("error 2\n");

  printf("%d,%s\n", jp.jp_valuelen, jp.jp_value);
    jailparam_free(&jp, JP_RAWVALUE);
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This one just doesn't works as expected. To see how its works, we'll
just make jls with GDB debug flag (-g) and start it to list all jails
running on my system.

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cd /usr/src/usr.sbin/jls
make CFLAGS+=-g
gdb /usr/obj/usr/src/usr.sbin/jls/jls
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gdb> break main
gdb> break print_jail
gdb> break jailparam_get
gdb> run
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 * https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html
 * http://www.unknownroad.com/rtfm/gdbtut/gdbbreak.html

After doing that, we see more about how works jailparam
datastructure. First thing, jls implement a new function to initialize
and update parameters: add_param(). We can add a new breakpoint on it
to see how this one works:

[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gdb> break add_param
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This function tell us lot of things. First, all jail parameters could
be listed with jailparam_all() function.

 * https://svnweb.freebsd.org/base/releng/11.0/usr.sbin/jls/jls.c?revision=303975&view=markup#l253
